---
title: "Niche hypervolume community vulnerability index"
author: ""
date: "26/06/2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Load vars data, include=FALSE}


library(readxl)
library(raster)
library(dplyr)
library(tidyr)
library(rasterVis)
library(RColorBrewer)
library(ggplot2)
library(ggcorrplot)

nicheVarsPath <- "../../OUT/nicheVars_v3.xlsx"

nv <- read_excel(nicheVarsPath)

spMods <- list.dirs("../../OUT/MODS_v2", recursive = FALSE, full.names = TRUE)

spNames <- basename(spMods)

```

```{r Get raster stacks, eval=FALSE, include=FALSE}
# pb <- txtProgressBar(min = 1, max = length(spNames), style = 3)
# 
# for(i in 1:length(spNames)){
#   
#   ensPath <- paste(spMods[i],"/proj_current/GeoTIFF/proj_current_",spNames[i],"_ensemble.tif",sep="")
#   binPath <- paste(spMods[i],"/proj_current/GeoTIFF/proj_current_",spNames[i],"_ensemble_TSSbin.tif",sep="")
#   
#   rstEns <- stack(ensPath)[[1]]
#   rstBin <- stack(binPath)[[1]]
#   
#   if(i==1){
#     rstEnsStack <- rstEns
#     rstBinStack <- rstBin
#   }else{
#     
#     # A small hack to correct for different extents in the projections...
#     if(!compareRaster(rstEns,rstEnsStack,stopiffalse = FALSE)){
#       message("\nResampling for rstEnsStack")
#       rstEns <- projectRaster(rstEns, rstEnsStack, method = 'ngb')
#     }
#     if(!compareRaster(rstBin,rstBinStack,stopiffalse = FALSE)){
#       message("\nResampling for rstBinStack")
#       rstBin <- projectRaster(rstBin, rstBinStack, method = 'ngb')
#     }
#     
#     rstEnsStack <- stack(rstEnsStack, rstEns)
#     rstBinStack <- stack(rstBinStack, rstBin)
#   }
#   
#   setTxtProgressBar(pb,i)
# }
#
#
# names(rstEnsStack) <- spNames
# names(rstBinStack) <- spNames
# 
# writeRaster(rstEnsStack,filename = "./OUT/rstEnsStack_multiSp_v2.grd")
# writeRaster(rstBinStack,filename = "./OUT/rstBinStack_multiSp_v2.grd")

```

```{r Calculate indicators, include=FALSE}

# Get raster stacks (faster! does not need to make resampling again)
rstEnsStack <- stack("../../OUT/rstEnsStack_multiSp_v2.grd")
rstBinStack <- stack("../../OUT/rstBinStack_multiSp_v2.grd")

# Calculate the HS sum and species richness
rstEnsStack_sum <- calc(rstEnsStack, fun = sum) 
rstBinStack_sum <- calc(rstBinStack, fun = sum) 

NHCVI_vec <- c()

i<-0
for(sp in spNames){
  
  i<- i + 1
  
  # Filter data to the i-th species
  vi <- nv %>% 
    filter(spName == sp) %>% 
    select(distToAvgCentr, hv_svm) %>% 
    as.numeric
  
  NHCVI_vec[i] <- (2*vi[2]) - vi[1]

}

znorm <- function(x) (x-min(x)) / (max(x) - min(x))

spVulnRank <- data.frame(Species = spNames,
                         NHCVI = NHCVI_vec,
                         NHCVI_norm = znorm(NHCVI_vec),
                         NHCVI_n_inv = 1 - znorm(NHCVI_vec)) %>% 
  arrange(desc(NHCVI_n_inv))

# Calculate the indices
i <- 0
pb <- txtProgressBar(min = 1, max = length(spNames), style = 3)
for(sp in spVulnRank$Species){
  
  i<- i + 1
  
  vulnScore <- spVulnRank[i,"NHCVI_n_inv"]
  
  NHCVI_bin_i <- rstBinStack[[sp]] * vulnScore
  NHCVI_ens_i <- rstEnsStack[[sp]] * vulnScore
  
  if(i==1){
    NHCVI_bin_sum <- NHCVI_bin_i
    NHCVI_ens_sum <- NHCVI_ens_i
    
    NHCVI_binStack <- NHCVI_bin_i
    NHCVI_ensStack <- NHCVI_ens_i
    
  }else{
    NHCVI_bin_sum <- NHCVI_bin_sum + NHCVI_bin_i
    NHCVI_ens_sum <- NHCVI_ens_sum + NHCVI_ens_i
    
    NHCVI_binStack <- stack(NHCVI_binStack, NHCVI_bin_i)
    NHCVI_ensStack <- stack(NHCVI_ensStack, NHCVI_ens_i)
    
  }
  setTxtProgressBar(pb,i)
}

# Normalize the indices by 

NHCVI_bin <- NHCVI_bin_sum / rstBinStack_sum
NHCVI_ens <- NHCVI_ens_sum / rstEnsStack_sum

NHCVI_bin_SD <- calc(NHCVI_binStack,fun = sd,na.rm=TRUE)
NHCVI_bin_Mx <- calc(NHCVI_binStack,fun = max,na.rm=TRUE)

NHCVI_ens_SD <- calc(NHCVI_ensStack,fun = sd, na.rm=TRUE)
NHCVI_ens_Mx <- calc(NHCVI_ensStack,fun = max, na.rm=TRUE)

NHCVI_ens1 <- NHCVI_ens
NHCVI_ens1[rstBinStack_sum==0] <- NA

writeRaster(NHCVI_bin,"NHCVI_bin.tif", overwrite = TRUE)
writeRaster(NHCVI_ens,"NHCVI_ens.tif", overwrite = TRUE)
writeRaster(NHCVI_ens1,"NHCVI_ens_gt0.tif", overwrite = TRUE)

```

## Initial definitions

For calculating the NHCVI the following formula is applied to each species $i$ 
considering either its binary output (i.e., 0,1) or its habitat suitability 
both obtained from Species Distribution Models:

(i) the binary case:

\begin{equation}
  \label{eq:1}
  NHCVI_{i} = \begin{cases} 0 \text{ if }                   SDM = 0 \\
                            2 N_{b,i} - N_{p,i} \text{ if } SDM = 1               
              \end{cases}
\end{equation}

Where $N_{b,i}$ and $N_{p,i}$ are, respectively, the Niche Breadth and the Niche Position for 
a given species $i$.    
In this case, $N_{b,i}$ is given by the SVM-based hypervolume size, and, $N_{p,i}$ is based 
on the average Euclidean distance between the $i$-th species centroid and the global community 
centroid.     
In a nutshell, this index intends to maximize vulnerability for species with smaller niche 
breadth and higher marginality in the community environmental suitable/niche space.

(ii) the habitat suitability case:   

\begin{equation}
  \label{eq:2}
  NHCVI_{i} = H_{s,i} \times (2N_{b,i} - N_{p,i})
\end{equation}
  
Where $H_{s,i}$ is the habitat suitability value (rescaled by biomod2 between 0-1000) 
for a given species $i$.

For obtaining a spatial representation of the index for all species in the community, 
we can calculate the sum as:

\begin{equation}
  \label{eq:3}
  NHCVI_{s} = \sum_{i=1}^{N}H_{s,i} \times (2N_{b,i} - N_{p,i})
\end{equation}

With $N$ equal to the total number of species in the community.    

Because higher species richness will result in greater vulnerability, we may need to 
normalize this as:

(i) the binary case:

\begin{equation}
  \label{eq:4}
  NHCVI_{bin} = \frac{1}{N} \sum_{i=1}^{N} 2N_{b,i} - N_{p,i}
\end{equation}

(ii) the habitat suitability case: 

\begin{equation}
  \label{eq:5}
  NHCVI_{HS} = \frac{\sum_{i=1}^{N}H_{s,i} \times (2N_{b,i} - N_{p,i})}{\sum_{i=1}^{N}H_{s,i}}
\end{equation}

Because large values for both $NHCVI_{bin}$ and $NHCVI_{HS}$ relate to low vulnerability 
it may be useful and more intuitive to use the reciprocal (or the multiplicative inverse) 
of these indices as:

\begin{equation}
  \label{eq:6}
  NHCVI'_{bin} = \frac{1}{NHCVI_{bin}}
\end{equation}

Or:

\begin{equation}
  \label{eq:7}
  NHCVI'_{HS} = \frac{1}{NHCVI_{HS}}
\end{equation}


## Results

### Species ranking in terms of vulnerability

The table is sorted by $NHCVI$ (\ref{eq:1}) from the highest vulnerable species to the 
least vulnerable one:

```{r Species vulnerability ranking, echo=FALSE, message=FALSE, warning=FALSE}

library(knitr)

# spVulnRank <- data.frame(Species = spNames,
#                          NHCVI = NHCVI_vec,
#                          NHCVI_inv = 1 / NHCVI_vec) %>% 
#   arrange(NHCVI)

kable(spVulnRank, digits = 3, format = "latex")

```

       
### Species Richness

Darker green tones depict highest levels of species richness in the map (pixels with zero species
have been converted to NODATA for better visualization):

```{r echo=FALSE, message=FALSE, warning=FALSE}

rstBinStack_sum1 <- rstBinStack_sum
rstBinStack_sum1[rstBinStack_sum == 0] <- NA

mapTheme <- rasterTheme(region=brewer.pal(8,"Greens"))
levelplot(rstBinStack_sum1, margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE ))

```


The following maps present species richness across four 
different levels of species vulnerability:

- Very-low: in blue tones
- Low-Medium: in green tones
- Medium-High: in orange tones
- Very-high: in red.


```{r message=FALSE, warning=FALSE, include=FALSE}

library(classInt)

vlevs <- c(
  "Very-low",
 "Low-Medium",
 "Medium-High",
 "Very-high")

pals <- c("Blues","Greens","Oranges","Reds")

brks <- classIntervals(spVulnRank$NHCVI_n_inv, n=4, style="jenks")
print(brks)

for(i in 1:(length(brks$brks)-1)){
  
  a <- brks$brks[i]
  b <- brks$brks[i+1]
  
  if(i==1){
    spn <- spVulnRank %>% 
      filter(NHCVI_n_inv>=a,NHCVI_n_inv<=b) %>% 
      select(Species) %>% 
      pull
  }else{
    spn <- spVulnRank %>% 
      filter(NHCVI_n_inv>a,NHCVI_n_inv<=b)  %>% 
      select(Species) %>% 
      pull
  }
  
  rstBinStack_vrank <- calc(rstBinStack[[spn]], fun = sum) 
  rstBinStack_vrank1 <- rstBinStack_vrank
  rstBinStack_vrank1[rstBinStack_vrank == 0] <- NA
  
  if(i==1)
    rst_VulnSpR <- rstBinStack_vrank1
  else
    rst_VulnSpR <- stack(rst_VulnSpR, rstBinStack_vrank1)

}

```


```{r echo=FALSE, message=FALSE, warning=FALSE}

mapTheme <- rasterTheme(region=brewer.pal(8,pals[1]))
levelplot(rst_VulnSpR[[1]], margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE), main=paste(vlevs[1],"vulnerability"))


mapTheme <- rasterTheme(region=brewer.pal(8,pals[2]))
levelplot(rst_VulnSpR[[2]], margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE), main=paste(vlevs[2],"vulnerability"))


mapTheme <- rasterTheme(region=brewer.pal(8,pals[3]))
levelplot(rst_VulnSpR[[3]], margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE), main=paste(vlevs[3],"vulnerability"))


mapTheme <- rasterTheme(region=brewer.pal(8,pals[4]))
levelplot(rst_VulnSpR[[4]], margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE), main=paste(vlevs[4],"vulnerability"))

```


### NHCVI_bin (binary version, normalized by species richness)

The following map shows the application of (\ref{eq:4}) with red tones showing less 
vulnerable areas in contrast to blue tones highlighting more vulnerable areas.

```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(NHCVI_bin, margin=F, par.settings = BuRdTheme(),
          scales=list(draw=FALSE ))

```


```{r echo=FALSE, message=FALSE, warning=FALSE}

NHCVI_bin_SD1<-NHCVI_bin_SD
NHCVI_bin_SD1[rstBinStack_sum == 0] <- NA

mapTheme <- rasterTheme(region=brewer.pal(8,"Greens"))
levelplot(NHCVI_bin_SD1, margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE), main="Std-dev of NHCVI binary")


```

```{r echo=FALSE, message=FALSE, warning=FALSE}

NHCVI_bin_Mx1 <- NHCVI_bin_Mx
NHCVI_bin_Mx1[rstBinStack_sum == 0] <- NA

mapTheme <- rasterTheme(region=brewer.pal(8,"Oranges"))
levelplot(NHCVI_bin_Mx1, margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE), main="Maximum of NHCVI binary")


```


### NHCVI_HS (Hab. suit., normalized by habitat suitability sum across all species)

The following map shows the application of (\ref{eq:5}) with red tones showing less 
vulnerable areas in contrast to blue tones highlighting more vulnerable areas.
       
```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(NHCVI_ens1, margin=F, par.settings = BuRdTheme(),
          scales=list(draw=FALSE ))

```


```{r echo=FALSE, message=FALSE, warning=FALSE}

NHCVI_ens_SD1<-NHCVI_ens_SD
NHCVI_ens_SD1[rstBinStack_sum == 0] <- NA

mapTheme <- rasterTheme(region=brewer.pal(8,"Greens"))
levelplot(NHCVI_ens_SD1, margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE), main="Std-dev of NHCVI HS")


```

```{r echo=FALSE, message=FALSE, warning=FALSE}

NHCVI_ens_Mx1<-NHCVI_ens_Mx
NHCVI_ens_Mx1[rstBinStack_sum == 0] <- NA

mapTheme <- rasterTheme(region=brewer.pal(8,"Oranges"))
levelplot(NHCVI_ens_Mx1, margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE), main="Maximum of NHCVI Hab suitb.")


writeRaster(NHCVI_ens_Mx1,"./NHCVI_ens_Mx1.tif", overwrite = TRUE)

```

