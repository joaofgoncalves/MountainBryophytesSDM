---
title: "Niche hypervolume community vulnerability index"
author: "João Gonçalves"
date: "23/06/2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Load vars data, include=FALSE}


library(readxl)
library(raster)
library(dplyr)
library(tidyr)
library(rasterVis)
library(RColorBrewer)
library(ggplot2)
library(ggcorrplot)

nicheVarsPath <- "../../OUT/nicheVars_v3.xlsx"

nv <- read_excel(nicheVarsPath)

spMods <- list.dirs("../../OUT/MODS_v2", recursive = FALSE, full.names = TRUE)

spNames <- basename(spMods)

```

```{r Get raster stacks, eval=FALSE, include=FALSE}
# pb <- txtProgressBar(min = 1, max = length(spNames), style = 3)
# 
# for(i in 1:length(spNames)){
#   
#   ensPath <- paste(spMods[i],"/proj_current/GeoTIFF/proj_current_",spNames[i],"_ensemble.tif",sep="")
#   binPath <- paste(spMods[i],"/proj_current/GeoTIFF/proj_current_",spNames[i],"_ensemble_TSSbin.tif",sep="")
#   
#   rstEns <- stack(ensPath)[[1]]
#   rstBin <- stack(binPath)[[1]]
#   
#   if(i==1){
#     rstEnsStack <- rstEns
#     rstBinStack <- rstBin
#   }else{
#     
#     # A small hack to correct for different extents in the projections...
#     if(!compareRaster(rstEns,rstEnsStack,stopiffalse = FALSE)){
#       message("\nResampling for rstEnsStack")
#       rstEns <- projectRaster(rstEns, rstEnsStack, method = 'ngb')
#     }
#     if(!compareRaster(rstBin,rstBinStack,stopiffalse = FALSE)){
#       message("\nResampling for rstBinStack")
#       rstBin <- projectRaster(rstBin, rstBinStack, method = 'ngb')
#     }
#     
#     rstEnsStack <- stack(rstEnsStack, rstEns)
#     rstBinStack <- stack(rstBinStack, rstBin)
#   }
#   
#   setTxtProgressBar(pb,i)
# }
#
#
# names(rstEnsStack) <- spNames
# names(rstBinStack) <- spNames
# 
# writeRaster(rstEnsStack,filename = "./OUT/rstEnsStack_multiSp_v2.grd")
# writeRaster(rstBinStack,filename = "./OUT/rstBinStack_multiSp_v2.grd")

```

```{r Calculate indicators, include=FALSE}

# Get raster stacks (faster! does not need to make resampling again)
rstEnsStack <- stack("../../OUT/rstEnsStack_multiSp_v2.grd")
rstBinStack <- stack("../../OUT/rstBinStack_multiSp_v2.grd")

# Calculate the HS sum and species richness
rstEnsStack_sum <- calc(rstEnsStack, fun = sum) 
rstBinStack_sum <- calc(rstBinStack, fun = sum) 

NHCVI_vec <- c()

# Calculate the indices
i <- 0
pb <- txtProgressBar(min = 1, max = length(spNames), style = 3)
for(sp in spNames){
  
  i<- i + 1
  
  # Filter data to the i-th species
  vi <- nv %>% 
    filter(spName == sp) %>% 
    select(distToAvgCentr, hv_svm) %>% 
    as.numeric
  
  # vi[1] distToAvgCentr
  # vi[2] hv_svm (used because has no negative values in contrast to the log version)
  
  NHCVI_bin_i <- 2*(rstBinStack[[i]] * vi[2]) - (rstBinStack[[i]] * vi[1])
  NHCVI_ens_i <- 2*(rstEnsStack[[i]] * vi[2]) - (rstEnsStack[[i]] * vi[1])
  
  NHCVI_vec[i] <- (2*vi[2]) - vi[1]
  
  if(i==1){
    NHCVI_bin_sum <- NHCVI_bin_i
    NHCVI_ens_sum <- NHCVI_ens_i
  }else{
    NHCVI_bin_sum <- NHCVI_bin_sum + NHCVI_bin_i
    NHCVI_ens_sum <- NHCVI_ens_sum + NHCVI_ens_i
  }
  setTxtProgressBar(pb,i)
}

# Normalize the indices by 
NHCVI_bin <- NHCVI_bin_sum / rstBinStack_sum
NHCVI_ens <- NHCVI_ens_sum / rstEnsStack_sum

```

## Initial definitions

For calculating the NHCVI the following formula is applied to each species $i$ 
considering either its binary output (i.e., 0,1) or its habitat suitability 
both obtained from Species Distribution Models:

(i) the binary case:

$$NHCVI_{i} = \begin{cases} 0 \text{ if }                      SDM = 0 \\
                            2 N_{b,i} - N_{p,i} \text{ if } SDM = 1               
                                          \end{cases}$$

Where $N_{b,i}$ and $N_{p,i}$ are, respectively, the Niche Breadth and the Niche Position for 
a given species $i$.    
In this case, $N_{b,i}$ is given by the SVM-based hypervolume size, and, $N_{p,i}$ is based 
on the average Euclidean distance between the $i$-th species centroid and the global community 
centroid.     
In a nutshell, this index intends to maximize vulnerability for species with smaller niche 
breadth and higher marginality in the community environmental suitable/niche space.

(ii) the habitat suitability case:   

\begin{equation}
  \label{eq:1}
  NHCVI_{i} = H_{s,i} \times (2N_{b,i} - N_{p,i})
\end{equation}
  
Where $H_{s,i}$ is the habitat suitability value (rescaled by biomod2 between 0-1000) 
for a given species $i$.

For obtaining a spatial representation of the index for all species in the community, 
we can calculate the sum as:

$$NHCVI_{i} = \sum_{i=1}^{N}H_{s,i} \times (2N_{b,i} - N_{p,i})$$
With $N$ equal to the total numbr of species in the community.    

Because higher species richness will result in greater vulnerability, we may need to 
normalize this as:

(i) the binary case:

$$NHCVI_{bin} = \frac{1}{N} \sum_{i=1}^{N} 2N_{b,i} - N_{p,i}$$

(ii) the habitat suitability case: 

$$NHCVI_{HS} = \frac{\sum_{i=1}^{N}H_{s,i} \times (2N_{b,i} - N_{p,i})}{\sum_{i=1}^{N}H_{s,i}}$$

Because large values for both $NHCVI_{bin}$ and $NHCVI_{HS}$ relate to low vulnerability 
it may be useful and more intuitive to use the reciprocal (or the multiplicative inverse) 
of these indices as:

$$NHCVI'_{bin} = \frac{1}{NHCVI_{bin}}$$
Or:

$$NHCVI'_{HS} = \frac{1}{NHCVI_{HS}}$$

## Results

### Species ranking in terms of vulnerability

The table is sorted by $NHCVI$ from the highest vulnerable species to the 
least vulnerable one:

```{r Species vulnerability ranking, echo=FALSE, message=FALSE, warning=FALSE}

library(knitr)

spVulnRank <- data.frame(Species = spNames,
                         NHCVI = NHCVI_vec,
                         Inv_NHCVI = 1 / NHCVI_vec) %>% 
  arrange(NHCVI)

kable(spVulnRank, digits = 3, format = "latex")

```

       
### Species Richness

Darker green tones depict highest levels of species richness in the map:

```{r echo=FALSE, message=FALSE, warning=FALSE}

mapTheme <- rasterTheme(region=brewer.pal(8,"Greens"))
levelplot(rstBinStack_sum, margin=F, par.settings = mapTheme)

```


### NHCVI sum (binary version, non-normalized)
 

        
```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(NHCVI_bin_sum, margin=F, par.settings = BuRdTheme())

```


### NHCVI sum (Hab. suitb., non-normalized)
        
```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(NHCVI_ens_sum, margin=F, par.settings = BuRdTheme())

```


### NHCVI sum (binary version, normalized by species richness)
         
```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(NHCVI_bin, margin=F, par.settings = BuRdTheme())

```


### NHCVI sum inverse (binary version, normalized by species richness)
        
```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(1 / NHCVI_bin, margin=F, par.settings = BuRdTheme())

```


### NHCVI sum (Hab. suitb., normalized by HS sum across all species)
        
```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(NHCVI_ens, margin=F, par.settings = BuRdTheme())

```
     
     
### NHCVI sum inverse (Hab. suitb., normalized by HS sum across all species)
        
```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(1 / NHCVI_ens, margin=F, par.settings = BuRdTheme())

```
     

### Spearman correlation between NHCVI and Species Richness
        
        
```{r echo=FALSE, message=FALSE, warning=FALSE}

r <- stack(rstBinStack_sum,
      rstEnsStack_sum,
      NHCVI_bin_sum,
      NHCVI_ens_sum,
      NHCVI_bin,
      NHCVI_ens)

names(r) <- c("SpR","HS_sum","NHCVI_Binsum","NHCVI_HSsum",
              "NHCVI_BinNorm","NHCVI_HSnorm")

rval <- na.omit(values(r))

cm <- cor(rval, method="spearman")

ggcorrplot(cm,
           type = "lower",
           lab = TRUE)

```


### Spearman local correlation between NHCVI and Species Richness

       
#### Binary-based NHCVI (local correlation)
       
Window-size = 5x5 Km            
    

```{r echo=FALSE, message=FALSE, warning=FALSE}

clSpear_NHCVI_bin_sum <- corLocal(x = rstBinStack_sum, y = NHCVI_bin_sum, 
                                  ngb=5, method=c("spearman"), test=FALSE)

mapTheme <- rasterTheme(region=brewer.pal(8,"PiYG"))
levelplot(clSpear_NHCVI_bin_sum, margin=F, par.settings = mapTheme)


```


#### Habitat suitability-based NHCVI (local correlation)
        
Window-size = 5x5 Km          
     

```{r echo=FALSE, message=FALSE, warning=FALSE}

clSpear_NHCVI_ens_sum <- corLocal(x = rstEnsStack_sum, y = NHCVI_ens_sum, 
                                  ngb=5, method=c("spearman"), test=FALSE)

mapTheme <- rasterTheme(region=brewer.pal(8,"PiYG"))
levelplot(clSpear_NHCVI_ens_sum, margin=F, par.settings = mapTheme)


```


