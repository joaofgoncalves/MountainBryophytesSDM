---
title: "Niche hypervolume community vulnerability index"
author: ""
date: "27/11/2021"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Load vars data, include=FALSE}


library(readxl)
library(raster)
library(dplyr)
library(tidyr)
library(rasterVis)
library(RColorBrewer)
library(ggplot2)
library(ggcorrplot)

nicheVarsPath <- "../../OUT/nicheVars_v3.xlsx"

nv <- read_excel(nicheVarsPath)

spMods <- list.dirs("../../OUT/MODS_v2", recursive = FALSE, full.names = TRUE)

spNames <- basename(spMods)

```

```{r Calculate indicators, include=FALSE}

# Get raster stacks (faster! does not need to make resampling again)
rstEnsStack <- stack("../../OUT/rstEnsStack_multiSp_v2.grd")
rstBinStack <- stack("../../OUT/rstBinStack_multiSp_v2.grd")

# Calculate the HS sum and species richness
rstEnsStack_sum <- calc(rstEnsStack, fun = sum) 
rstBinStack_sum <- calc(rstBinStack, fun = sum) 

NHCVI_vec <- c()

i<-0
for(sp in spNames){
  
  i<- i + 1
  
  # Filter data to the i-th species
  vi <- nv %>% 
    filter(spName == sp) %>% 
    select(distToAvgCentr, hv_svm) %>% 
    as.numeric
  
  NHCVI_vec[i] <- (2*vi[2]) - vi[1]

}

znorm <- function(x) (x-min(x)) / (max(x) - min(x))

spVulnRank <- data.frame(Species = spNames,
                         NHCVI = NHCVI_vec,
                         NHCVI_norm = znorm(NHCVI_vec),
                         NHCVI_n_inv = 1 - znorm(NHCVI_vec)) %>% 
  arrange(desc(NHCVI_n_inv))

# Calculate the indices
i <- 0
pb <- txtProgressBar(min = 1, max = length(spNames), style = 3)
for(sp in spVulnRank$Species){
  
  i<- i + 1
  
  vulnScore <- spVulnRank[i,"NHCVI_n_inv"]
  
  NHCVI_bin_i <- rstBinStack[[sp]] * vulnScore
  NHCVI_ens_i <- rstEnsStack[[sp]] * vulnScore * rstBinStack[[sp]]
  
  if(i==1){
    NHCVI_bin_sum <- NHCVI_bin_i
    NHCVI_ens_sum <- NHCVI_ens_i
    
    NHCVI_binStack <- NHCVI_bin_i
    NHCVI_ensStack <- NHCVI_ens_i
    
  }else{
    NHCVI_bin_sum <- NHCVI_bin_sum + NHCVI_bin_i
    NHCVI_ens_sum <- NHCVI_ens_sum + NHCVI_ens_i
    
    NHCVI_binStack <- stack(NHCVI_binStack, NHCVI_bin_i)
    NHCVI_ensStack <- stack(NHCVI_ensStack, NHCVI_ens_i)
    
  }
  setTxtProgressBar(pb,i)
}

# Calculate aggregation stats per pixel

NHCVI_ens_AVG <- calc(NHCVI_ensStack,fun = mean, na.rm=TRUE)
NHCVI_ens_MED <- calc(NHCVI_ensStack,fun = median, na.rm=TRUE)
NHCVI_ens_STD <- calc(NHCVI_ensStack,fun = sd, na.rm=TRUE)
NHCVI_ens_MAD <- calc(NHCVI_ensStack,fun = mad, na.rm=TRUE)
NHCVI_ens_MAX <- calc(NHCVI_ensStack,fun = max, na.rm=TRUE)



NHCVI_ens_AVG1 <- NHCVI_ens_AVG
NHCVI_ens_AVG1[rstBinStack_sum==0] <- NA
writeRaster(NHCVI_ens_AVG,"NHCVI_Hs_AVG_v2.tif", overwrite = TRUE)
writeRaster(NHCVI_ens_AVG1,"NHCVI_Hs_AVG_wNAs_v2.tif", overwrite = TRUE)

NHCVI_ens_MED1 <- NHCVI_ens_MED
NHCVI_ens_MED1[rstBinStack_sum==0] <- NA
writeRaster(NHCVI_ens_MED,"NHCVI_Hs_MED_v2.tif", overwrite = TRUE)
writeRaster(NHCVI_ens_MED1,"NHCVI_Hs_MED_wNAs_v2.tif", overwrite = TRUE)

NHCVI_ens_STD1 <- NHCVI_ens_STD
NHCVI_ens_STD1[rstBinStack_sum==0] <- NA
writeRaster(NHCVI_ens_STD,"NHCVI_Hs_STD_v2.tif", overwrite = TRUE)
writeRaster(NHCVI_ens_STD1,"NHCVI_Hs_STD_wNAs_v2.tif", overwrite = TRUE)

NHCVI_ens_MAD1 <- NHCVI_ens_MAD
NHCVI_ens_MAD1[rstBinStack_sum==0] <- NA
writeRaster(NHCVI_ens_MAD,"NHCVI_Hs_MAD_v2.tif", overwrite = TRUE)
writeRaster(NHCVI_ens_MAD1,"NHCVI_Hs_MAD_wNAs_v2.tif", overwrite = TRUE)

NHCVI_ens_MAX1 <- NHCVI_ens_MAX
NHCVI_ens_MAX1[rstBinStack_sum==0] <- NA
writeRaster(NHCVI_ens_MAX,"NHCVI_Hs_MAX_v2.tif", overwrite = TRUE)
writeRaster(NHCVI_ens_MAX1,"NHCVI_Hs_MAX_wNAs_v2.tif", overwrite = TRUE)

```


## Initial definitions

For calculating the NHCVI the following formula is applied to each species $i$:

\begin{equation}
  \label{eq:1}
  NHCVI_{i} = 2 N_{b,i} - N_{p,i}              
\end{equation}

Where $N_{b,i}$ and $N_{p,i}$ are, respectively, the Niche Breadth and the Niche Position for 
a given species $i$.    
In this case, $N_{b,i}$ is given by the __SVM-based hypervolume size__, and, $N_{p,i}$ is based 
on the __Euclidean distance__ between the $i$-th species centroid and the community-wise general 
centroid.     
In a nutshell, this index intends to give maximum vulnerability for species with smaller niche 
breadth and higher marginality in the community environmental suitable/niche space. The index 
attributes more weight to niche breadth since this variable was selected in a greater number of 
times in models explaining range shifts. Nonetheless, this can be changed by defining specific 
weights to each component of the index as: $NHCVI_{i} = w_{1}N_{b,i} - w_{2}N_{p,i}$ 
with, $w_{1}$ and $w_{2}$ respectively as the weights for niche breadth and position. 

After calculating the $NHCVI_{i}$ for each species $i$ in the community, values are normalized 
within the 0 - 1 range as follows:

\begin{equation}
  \label{eq:2}
  NHCVI'_{i} = \frac{NHCVI_{i} - min(NHCVI_{i=1,...,N})}{max(NHCVI_{i=1,...,N}) - min(NHCVI_{i=1,...,N})}
\end{equation}


The $NHCVI_{i=1,...,N}$ represents a vector containing all species values in the community.

Because $NHCVI'_{i}$ attributes higher values to species less vulnerable, we calculate 
the reciprocal to make it more easily interpretable as:

\begin{equation}
  \label{eq:3}
  NHCVI''_{i} = 1 - NHCVI'_{i}
\end{equation}

After calculating [\ref{eq:3}] we obtain the final vulnerability score for each species 
in the community. It should be noted that a score of zero in index $NHCVI''_{i}$ does 
not mean a species is not vulnerable, this simply derives from the normalization of 
the score across species in the target community.

Next, to generate a spatial representation of the index we multiply this score by the 
habitat suitability of each species from the habitat suitability maps from biomod2. This 
way we attribute higher vulnerability to those locations where the species is more likely 
to have suitable environmental conditions. Calculations are performed at pixel-level for 
each species $i = {1,...N}$  in the community (with $N$ equal to the total number of species) 
and implement the following simple formula: 

\begin{equation}
  \label{eq:4}
  NHCVIhs_{i} = H_{s,i} \times NHCVI''_{i}
\end{equation}
  
Where $H_{s,i}$ is the habitat suitability value (rescaled by biomod2 between 0-1000) 
for a given species $i$.

By applying eqn. [\ref{eq:4}] we obtain a stack of vulnerability maps, one for each species with each 
pixel, $p$ (in a particular x,y location) - mapped as: $p \rightarrow (x,y)$ - having a 
distribution of vulnerability values for the whole community. From this we can aggregate those 
values, noted as: $NHCVIhs_{i,x,y}$ and calculate certain quantities of interest, such as:

- the __average__ / __median__ for understanding centrality of vulnerability distribution;
- the __standard-deviation__ / __median absolute-deviation__ as a measure of dispersion of 
vulnerability rankings;
- the __Maximum__, as a representation of the greatest level of vulnerability found in a 
certain x,y location.


## Results

### Species ranking in terms of vulnerability

The table is sorted by $NHCVI''$ (eqn. \ref{eq:3}) from the highest vulnerable species to the 
least vulnerable one:

```{r Species vulnerability ranking, echo=FALSE, message=FALSE, warning=FALSE}

library(knitr)

# spVulnRank <- data.frame(Species = spNames,
#                          NHCVI = NHCVI_vec,
#                          NHCVI_inv = 1 / NHCVI_vec) %>% 
#   arrange(NHCVI)

kable(spVulnRank, digits = 3, format = "latex")

```

\newpage
       
### Species Richness

Darker green tones depict highest levels of species richness in the map (pixels with zero species
have been converted to NODATA for better visualization):

```{r echo=FALSE, message=FALSE, warning=FALSE}

rstBinStack_sum1 <- rstBinStack_sum
rstBinStack_sum1[rstBinStack_sum == 0] <- NA

mapTheme <- rasterTheme(region=brewer.pal(8,"Greens"))
levelplot(rstBinStack_sum1, margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE ))

```


The following maps present species richness across four 
different levels of species vulnerability:

- Very-low: in blue tones
- Low-Medium: in green tones
- Medium-High: in orange tones
- Very-high: in red.


```{r message=FALSE, warning=FALSE, include=FALSE}

library(classInt)

vlevs <- c(
 "Very-low",
 "Low-Medium",
 "Medium-High",
 "Very-high")

pals <- c("Blues","Greens","Oranges","Reds")

brks <- classIntervals(spVulnRank$NHCVI_n_inv, n=4, style="jenks")
print(brks)

for(i in 1:(length(brks$brks)-1)){
  
  a <- brks$brks[i]
  b <- brks$brks[i+1]
  
  if(i==1){
    spn <- spVulnRank %>% 
      filter(NHCVI_n_inv>=a,NHCVI_n_inv<=b) %>% 
      select(Species) %>% 
      pull
  }else{
    spn <- spVulnRank %>% 
      filter(NHCVI_n_inv>a,NHCVI_n_inv<=b)  %>% 
      select(Species) %>% 
      pull
  }
  
  rstBinStack_vrank <- calc(rstBinStack[[spn]], fun = sum) 
  rstBinStack_vrank1 <- rstBinStack_vrank
  rstBinStack_vrank1[rstBinStack_vrank == 0] <- NA
  
  if(i==1)
    rst_VulnSpR <- rstBinStack_vrank1
  else
    rst_VulnSpR <- stack(rst_VulnSpR, rstBinStack_vrank1)

}

writeRaster(rst_VulnSpR, "SpeciesRich_ByVulnrbtyGroup_v2.tif", overwrite = TRUE)

```


```{r echo=FALSE, message=FALSE, warning=FALSE}

mapTheme <- rasterTheme(region=brewer.pal(8,pals[1]))
levelplot(rst_VulnSpR[[1]], margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE), main=paste(vlevs[1],"vulnerability"))


mapTheme <- rasterTheme(region=brewer.pal(8,pals[2]))
levelplot(rst_VulnSpR[[2]], margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE), main=paste(vlevs[2],"vulnerability"))


mapTheme <- rasterTheme(region=brewer.pal(8,pals[3]))
levelplot(rst_VulnSpR[[3]], margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE), main=paste(vlevs[3],"vulnerability"))


mapTheme <- rasterTheme(region=brewer.pal(8,pals[4]))
levelplot(rst_VulnSpR[[4]], margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE), main=paste(vlevs[4],"vulnerability"))

```

\newpage

### NHCVI_HS 

The following map shows the application of different statistical aggregation measures to NHCVIhs 
with red tones showing less vulnerable areas in contrast to blue tones highlighting more vulnerable areas.
   
   
#### NHCVI_HS average


NHCVI_HS average

       
```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(NHCVI_ens_AVG1, margin=F, par.settings = BuRdTheme(),
          scales=list(draw=FALSE ))

```

\newpage

#### NHCVI_HS median


NHCVI_HS median

        
```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(NHCVI_ens_MED1, margin=F, par.settings = BuRdTheme(),
          scales=list(draw=FALSE ))

```

\newpage

#### NHCVI_HS standard-deviation
   

NHCVI_HS standard-deviation

       
```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(NHCVI_ens_STD1, margin=F, par.settings = BuRdTheme(),
          scales=list(draw=FALSE ))

```

\newpage

#### NHCVI_HS median absolute-deviation

   
NHCVI_HS median absolute-deviation


```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(NHCVI_ens_MAD1, margin=F, par.settings = BuRdTheme(),
          scales=list(draw=FALSE ))

```

\newpage

#### NHCVI_HS maximum


NHCVI_HS maximum
    
    
```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(NHCVI_ens_MAX1, margin=F, par.settings = BuRdTheme(),
          scales=list(draw=FALSE ))

```
