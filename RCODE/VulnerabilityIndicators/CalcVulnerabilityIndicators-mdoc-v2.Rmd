---
title: "Niche hypervolume community vulnerability index"
author: ""
date: "26/06/2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Load vars data, include=FALSE}


library(readxl)
library(raster)
library(dplyr)
library(tidyr)
library(rasterVis)
library(RColorBrewer)
library(ggplot2)
library(ggcorrplot)

nicheVarsPath <- "../../OUT/nicheVars_v3.xlsx"

nv <- read_excel(nicheVarsPath)

spMods <- list.dirs("../../OUT/MODS_v2", recursive = FALSE, full.names = TRUE)

spNames <- basename(spMods)

```

```{r Get raster stacks, eval=FALSE, include=FALSE}
# pb <- txtProgressBar(min = 1, max = length(spNames), style = 3)
# 
# for(i in 1:length(spNames)){
#   
#   ensPath <- paste(spMods[i],"/proj_current/GeoTIFF/proj_current_",spNames[i],"_ensemble.tif",sep="")
#   binPath <- paste(spMods[i],"/proj_current/GeoTIFF/proj_current_",spNames[i],"_ensemble_TSSbin.tif",sep="")
#   
#   rstEns <- stack(ensPath)[[1]]
#   rstBin <- stack(binPath)[[1]]
#   
#   if(i==1){
#     rstEnsStack <- rstEns
#     rstBinStack <- rstBin
#   }else{
#     
#     # A small hack to correct for different extents in the projections...
#     if(!compareRaster(rstEns,rstEnsStack,stopiffalse = FALSE)){
#       message("\nResampling for rstEnsStack")
#       rstEns <- projectRaster(rstEns, rstEnsStack, method = 'ngb')
#     }
#     if(!compareRaster(rstBin,rstBinStack,stopiffalse = FALSE)){
#       message("\nResampling for rstBinStack")
#       rstBin <- projectRaster(rstBin, rstBinStack, method = 'ngb')
#     }
#     
#     rstEnsStack <- stack(rstEnsStack, rstEns)
#     rstBinStack <- stack(rstBinStack, rstBin)
#   }
#   
#   setTxtProgressBar(pb,i)
# }
#
#
# names(rstEnsStack) <- spNames
# names(rstBinStack) <- spNames
# 
# writeRaster(rstEnsStack,filename = "./OUT/rstEnsStack_multiSp_v2.grd")
# writeRaster(rstBinStack,filename = "./OUT/rstBinStack_multiSp_v2.grd")

```

```{r Calculate indicators, include=FALSE}

# Get raster stacks (faster! does not need to make resampling again)
rstEnsStack <- stack("../../OUT/rstEnsStack_multiSp_v2.grd")
rstBinStack <- stack("../../OUT/rstBinStack_multiSp_v2.grd")

# Calculate the HS sum and species richness
rstEnsStack_sum <- calc(rstEnsStack, fun = sum) 
rstBinStack_sum <- calc(rstBinStack, fun = sum) 

NHCVI_vec <- c()

# Calculate the indices
i <- 0
pb <- txtProgressBar(min = 1, max = length(spNames), style = 3)
for(sp in spNames){
  
  i<- i + 1
  
  # Filter data to the i-th species
  vi <- nv %>% 
    filter(spName == sp) %>% 
    select(distToAvgCentr, hv_svm) %>% 
    as.numeric
  
  # vi[1] distToAvgCentr
  # vi[2] hv_svm (used because has no negative values in contrast to the log version)
  
  NHCVI_bin_i <- 2*(rstBinStack[[i]] * vi[2]) - (rstBinStack[[i]] * vi[1])
  NHCVI_ens_i <- 2*(rstEnsStack[[i]] * vi[2]) - (rstEnsStack[[i]] * vi[1])
  
  NHCVI_vec[i] <- (2*vi[2]) - vi[1]
  
  if(i==1){
    NHCVI_bin_sum <- NHCVI_bin_i
    NHCVI_ens_sum <- NHCVI_ens_i
  }else{
    NHCVI_bin_sum <- NHCVI_bin_sum + NHCVI_bin_i
    NHCVI_ens_sum <- NHCVI_ens_sum + NHCVI_ens_i
  }
  setTxtProgressBar(pb,i)
}

# Normalize the indices by 
NHCVI_bin <- NHCVI_bin_sum / rstBinStack_sum
NHCVI_ens <- NHCVI_ens_sum / rstEnsStack_sum

```

## Initial definitions

For calculating the NHCVI the following formula is applied to each species $i$ 
considering either its binary output (i.e., 0,1) or its habitat suitability 
both obtained from Species Distribution Models:

(i) the binary case:

\begin{equation}
  \label{eq:1}
  NHCVI_{i} = \begin{cases} 0 \text{ if }                   SDM = 0 \\
                            2 N_{b,i} - N_{p,i} \text{ if } SDM = 1               
              \end{cases}
\end{equation}

Where $N_{b,i}$ and $N_{p,i}$ are, respectively, the Niche Breadth and the Niche Position for 
a given species $i$.    
In this case, $N_{b,i}$ is given by the SVM-based hypervolume size, and, $N_{p,i}$ is based 
on the average Euclidean distance between the $i$-th species centroid and the global community 
centroid.     
In a nutshell, this index intends to maximize vulnerability for species with smaller niche 
breadth and higher marginality in the community environmental suitable/niche space.

(ii) the habitat suitability case:   

\begin{equation}
  \label{eq:2}
  NHCVI_{i} = H_{s,i} \times (2N_{b,i} - N_{p,i})
\end{equation}
  
Where $H_{s,i}$ is the habitat suitability value (rescaled by biomod2 between 0-1000) 
for a given species $i$.

For obtaining a spatial representation of the index for all species in the community, 
we can calculate the sum as:

\begin{equation}
  \label{eq:3}
  NHCVI_{s} = \sum_{i=1}^{N}H_{s,i} \times (2N_{b,i} - N_{p,i})
\end{equation}

With $N$ equal to the total number of species in the community.    

Because higher species richness will result in greater vulnerability, we may need to 
normalize this as:

(i) the binary case:

\begin{equation}
  \label{eq:4}
  NHCVI_{bin} = \frac{1}{N} \sum_{i=1}^{N} 2N_{b,i} - N_{p,i}
\end{equation}

(ii) the habitat suitability case: 

\begin{equation}
  \label{eq:5}
  NHCVI_{HS} = \frac{\sum_{i=1}^{N}H_{s,i} \times (2N_{b,i} - N_{p,i})}{\sum_{i=1}^{N}H_{s,i}}
\end{equation}

Because large values for both $NHCVI_{bin}$ and $NHCVI_{HS}$ relate to low vulnerability 
it may be useful and more intuitive to use the reciprocal (or the multiplicative inverse) 
of these indices as:

\begin{equation}
  \label{eq:6}
  NHCVI'_{bin} = \frac{1}{NHCVI_{bin}}
\end{equation}

Or:

\begin{equation}
  \label{eq:7}
  NHCVI'_{HS} = \frac{1}{NHCVI_{HS}}
\end{equation}


## Results

### Species ranking in terms of vulnerability

The table is sorted by $NHCVI$ (\ref{eq:1}) from the highest vulnerable species to the 
least vulnerable one:

```{r Species vulnerability ranking, echo=FALSE, message=FALSE, warning=FALSE}

library(knitr)

spVulnRank <- data.frame(Species = spNames,
                         NHCVI = NHCVI_vec,
                         NHCVI_inv = 1 / NHCVI_vec) %>% 
  arrange(NHCVI)

kable(spVulnRank, digits = 3, format = "latex")

```

       
### Species Richness

Darker green tones depict highest levels of species richness in the map:

```{r echo=FALSE, message=FALSE, warning=FALSE}

mapTheme <- rasterTheme(region=brewer.pal(8,"Greens"))
levelplot(rstBinStack_sum, margin=F, par.settings = mapTheme,
          scales=list(draw=FALSE ))

```


### NHCVI_bin (binary version, normalized by species richness)

The following map shows the application of (\ref{eq:4}) with red tones showing less 
vulnerable areas in contrast to blue tones highlighting more vulnerable areas.

```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(NHCVI_bin, margin=F, par.settings = BuRdTheme(),
          scales=list(draw=FALSE ))

```

### NHCVI_HS (Hab. suit., normalized by habitat suitability sum across all species)

The following map shows the application of (\ref{eq:5}) with red tones showing less 
vulnerable areas in contrast to blue tones highlighting more vulnerable areas.
       
```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(NHCVI_ens, margin=F, par.settings = BuRdTheme(),
          scales=list(draw=FALSE ))

```


### NHCVI_bin' (binary version, normalized by species richness)

The following map shows the application of (\ref{eq:6}) with blue tones showing less 
vulnerable areas in contrast to red tones highlighting more vulnerable areas.
        
```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(1 / NHCVI_bin, margin=F, par.settings = BuRdTheme(),
          scales=list(draw=FALSE ))

```

     
### NHCVI_HS' (Hab. suitb., normalized by HS sum across all species)
 
The following map shows the application of (\ref{eq:7}) with blue tones showing less 
vulnerable areas in contrast to red tones highlighting more vulnerable areas. 
       
```{r echo=FALSE, message=FALSE, warning=FALSE}

levelplot(1 / NHCVI_ens, margin=F, par.settings = BuRdTheme(),
          scales=list(draw=FALSE ))

```
     

### Spearman correlation between NHCVI and Species Richness
        
        
```{r echo=FALSE, message=FALSE, warning=FALSE}

r <- stack(rstBinStack_sum,
      rstEnsStack_sum,
      NHCVI_bin_sum,
      NHCVI_ens_sum,
      NHCVI_bin,
      NHCVI_ens,
      1/NHCVI_bin,
      1/NHCVI_ens)

names(r) <- c("SpR","HS_sum","NHCVI_bin_sum","NHCVI_HS_sum",
              "NHCVI_bin","NHCVI_HS","NHCVI_bin_inv","NHCVI_HS_inv")

rval <- na.omit(values(r))

cm <- cor(rval, method="spearman")

ggcorrplot(cm,
           type = "lower",
           lab = TRUE)

```




